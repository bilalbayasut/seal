# Terraform: Installation & Basic Usage

## Terraform Installation

**Prerequisites**

1. Installation instructions for [Terraform](https://learn.hashicorp.com/tutorials/terraform/install-cli).
2. Installation instructions for [AWS CLI](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html)
3. [AWS account](https://aws.amazon.com/free/) and [credentials](https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys) that would allow Terraform to manage resources. For this part we are interested in IAM User with programmatic access. We will require `AWS Access Key` and `AWS Secret Access Key`.

Once you installed Terraform, AWS CLI, and have your AWS credentials on hand we would need to add access keys environment variables. Your key will go between double-quotes, without the carets.

```bash
$ export AWS_ACCESS_KEY_ID="<YOUR_AWS_ACCESS_KEY_ID>"
```

```bash
$ export AWS_SECRET_ACCESS_KEY="<YOUR_AWS_SECRET_ACCESS_KEY>"
```

or put aws credentials in `~/.aws/credentials` like this :-

```ini
[default]
aws_access_key_id=XXXXXXXX
aws_secret_access_key=XXXXXXXX
aws_session_token=XXXXXXXX
```

After all these steps we can start using Terraform to manage our resources!

## Terraform Command Basics

### Terraform `init` command

### Terraform `validate` command

### Terraform `plan` command

### Terraform `apply` command

### Terraform `show` command

The `terraform show` command is used to provide human-readable output from a state or plan file. This can be used to inspect a plan to ensure that the planned operations are expected, or to inspect the current state as Terraform sees it.

Machine-readable output is generated by adding the `-json` command-line flag.

### Terraform `state` command

Advanced state management

#### Terraform `state list` command

The `terraform state list` command is used to list resources within a [Terraform state](https://developer.hashicorp.com/terraform/language/state).

#### Terraform `state show` command

The `terraform state show` command is used to show the attributes of a single resource in the [Terraform state](https://developer.hashicorp.com/terraform/language/state).

### Terraform `destroy` command

## Terraform Language Syntax

## Deploying our first infrastructure

We will start with a deploy of one EC2 instance. This will introduce you to the workflow of Terraform and basic structure of configuration files.

Enter these commands in the terminal to create a directory for our demo project and go into it:\


```bash
# Create folder with the name tf-demo
$ mkdir tf-demo
```

```bash
# Change into tf-demo folder
$ cd tf-demo
```

#### Creating our first configuration <a href="#creating-our-first-configuration" id="creating-our-first-configuration"></a>

Now that we are in our project's folder we need to create a `main.tf` file that will hold our configuration:\


```bash
$ touch main.tf
```

Open `main.tf` file with you favourite editor and paste this code:\


```hcl
# This block stores terraform settings
terraform {
  # We can define providers such as AWS, Azure, etc.
  # in this block along with their version and
  # where terraform should download them from.
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 3.27"
    }
  }
  # This is the version of Terraform we will use
  required_version = ">= 0.14.9"
}

# These are provider-specific settings
provider "aws" {
  profile = "default"
  region  = "us-west-2"
}

resource "aws_instance" "app_server" {
  ami           = "ami-830c94e3"
  instance_type = "t2.micro"

  tags = {
    Name = "PathToTerraformCertInstance"
  }
}
```

Next we will initialize Terraform in our folder:\


```bash
$ terraform init
# the output should contain this
Terraform has been successfully initialized!
```

If the code indentation is wrong, do not worry! Terraform provides a convenient command `fmt` that formats the code all nice and tidy. Let's try it:\


```bash
$ terraform fmt
```

Next step would be to check our configuration for syntactical errors. This is done using a `validate` command:\


```bash
$ terraform validate
# You should get this output
Success! The configuration is valid.
```

Before we deploy any resources it is a good idea to see what Terraform intends to do with the configuration we wrote. We will do this using `plan` command:\


```bash
$ terraform plan
# output
Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the
following symbols:
  + create

Terraform will perform the following actions:

  # aws_instance.app_server will be created
  + resource "aws_instance" "app_server" {
      + ami                                  = "ami-830c94e3"
      + arn                                  = (known after apply)
      + associate_public_ip_address          = (known after apply)
      + availability_zone                    = (known after apply)
      + cpu_core_count                       = (known after apply)
      + cpu_threads_per_core                 = (known after apply)
      + disable_api_stop                     = (known after apply)
      + disable_api_termination              = (known after apply)
      + ebs_optimized                        = (known after apply)
      + get_password_data                    = false
      + host_id                              = (known after apply)
      + host_resource_group_arn              = (known after apply)
      + iam_instance_profile                 = (known after apply)
      + id                                   = (known after apply)
      + instance_initiated_shutdown_behavior = (known after apply)
      + instance_lifecycle                   = (known after apply)
      + instance_state                       = (known after apply)
      + instance_type                        = "t2.micro"
      + ipv6_address_count                   = (known after apply)
      + ipv6_addresses                       = (known after apply)
      + key_name                             = (known after apply)
      + monitoring                           = (known after apply)
      + outpost_arn                          = (known after apply)
      + password_data                        = (known after apply)
      + placement_group                      = (known after apply)
      + placement_partition_number           = (known after apply)
      + primary_network_interface_id         = (known after apply)
      + private_dns                          = (known after apply)
      + private_ip                           = (known after apply)
      + public_dns                           = (known after apply)
      + public_ip                            = (known after apply)
      + secondary_private_ips                = (known after apply)
      + security_groups                      = (known after apply)
      + source_dest_check                    = true
      + spot_instance_request_id             = (known after apply)
      + subnet_id                            = (known after apply)
      + tags                                 = {
          + "Name" = "PathToTerraformCertInstance"
        }
      + tags_all                             = {
          + "Name" = "PathToTerraformCertInstance"
        }
      + tenancy                              = (known after apply)
      + user_data                            = (known after apply)
      + user_data_base64                     = (known after apply)
      + user_data_replace_on_change          = false
      + vpc_security_group_ids               = (known after apply)

      + capacity_reservation_specification (known after apply)

      + cpu_options (known after apply)

      + ebs_block_device (known after apply)

      + enclave_options (known after apply)

      + ephemeral_block_device (known after apply)

      + instance_market_options (known after apply)

      + maintenance_options (known after apply)

      + metadata_options (known after apply)

      + network_interface (known after apply)

      + private_dns_name_options (known after apply)

      + root_block_device (known after apply)
    }

Plan: 1 to add, 0 to change, 0 to destroy.

─────────────────────────────────────────────────────────────────

Note: You didn't use the -out option to save this plan, so
Terraform can't guarantee to take exactly these actions if you
run "terraform apply" now.
```

As you can see the output is pretty long, a thing to note is that we can output all this data to a file for analysis.

Everything looks good. Let's deploy our first resource using Terraform!\
\*You will be asked to approve deployment, you'd need to type `yes` to begin deployment process.\


```bash
$ terraform apply
# output
Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value: yes

aws_instance.app_server: Creating...
aws_instance.app_server: Still creating... [10s elapsed]
aws_instance.app_server: Still creating... [20s elapsed]
aws_instance.app_server: Still creating... [30s elapsed]
aws_instance.app_server: Still creating... [40s elapsed]
aws_instance.app_server: Creation complete after 45s [id=i-02bb0dc43fdd214d3]

Apply complete! Resources: 1 added, 0 changed, 0 destroyed.
```

Congratulations! You have just deployed your first resource using Infrastructure as Code!

We can check the state of Terraform-managed resources:\


```bash
$ terraform state list
# output
aws_instance.app_server
```

Great! Now it is time to take our instance down. It is done using aptly-named command `destroy`, you will need to approve this command with `yes` when prompted:\


```bash
$ terraform destroy
# output
Destroy complete! Resources: 1 destroyed.
```

## Demo : Try terraform basic commands in our first infrastructure
